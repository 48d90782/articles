В данной статье мы рассмотрим возможности FFI появившегося в PHP версии 7.4, сравним возможности работать PHP с такими языками как Go, Rust, C++ без создания плагинов, а напрямую, а так-же где возможно вам пригодится использование данной функции, а где не стоит по нашему мнению.

Итак, что такое FFI: (https://en.wikipedia.org/wiki/Foreign_function_interface)
FFI это возможность вызвать библиотечную функицю написанную на одном языке из другого языка. К примеру, как вы догадываетесь, вызвать из PHP функцию написанную на Rust/C++/Go. Для того, чтобы связать интерпретируемый язык с комиллируемым используется библиотека libffi (https://en.wikipedia.org/wiki/Libffi). Так как интерпретируемые языки не знают, где конкретко (в каких регистрах) искать параметры вызываемой функции, а так-же, где забирать результаты работы функции после вызова. Всю это работу для интерпретируемых языков делает Libffi. Так-же, эту библиотеку ну нужно устанавливать, она является частью системных библиотек (Linux).
Все эксперименты будут проводиться на ArchLinux (5.6.1 kernel), Libffi 3.2.1.

Для чего это делается. Это конечно интересно, исследовать новые языковые фишки, но есть ли в этом практический смысл. Это я постараюсь доказать по ходу статьи.

Итак, PHP.
https://www.php.net/manual/en/intro.ffi.php
В самом заголовке сразу описывается, что на момент написания статьи - это эксперементальная особенность языка PHP.
Для нашего примера, мы возьмем такую интересную задачу, как расчем последовательности фибоначчи. И конечно, не самым эффективным способом, через рекурсию. Это сделано для того, чтобы как можно сильнее задействовать процессор, а так-же, чтобы не дать компиллируемым языкам оптимизоровать данную функцию (к примеру, применив технику размотки цикла https://en.wikipedia.org/wiki/Loop_unrolling)

Приступим.
Для PHP первое, что мы должны сделать, это раскомментировать расширение ffi в php.ini (/etc/php/php.ini в ArchLinux).
Далее нам нужно объявить наш условный интерфейс. Есть некоторые ограничения, которые в данный момент присутствуют в PHP FFI, это в частности невозможность использования C-препроцессора (#include, #define и т.д, кроме некоторых специальных)
```php
$ffi = FFI::cdef(
     "int Fib(int n);",
    "/PATH/TO/SO/lib.so");
```

1. `FFI::cdef` - этой операцией мы определяем интерфейс взаимодействия.
2. `int Fib(int n)` - это название экспортируемого метода компиллируемого языка. Чуть ниже мы поговорим как это правильно сделать.
3. `/PATH/TO/SO/lib.so` - путь к shared библиотеке в которой находится функция выше.

Давайте попробуем сделать эту shared библиотеку на языке Rust (https://www.rust-lang.org/)
Для этого потребуется подготовка:
1. На любой платформе, для установки нам потребуется всего лишь одна инструкция отсюда - https://rustup.rs/
2. После этого создадим проект в любом месте командой `cargo new rust_php_ffi`. И все)

Это наша функция:
```rust
//src/lib.rs

#[no_mangle]
extern "C" fn Fib(n: i32) -> i32 {
    if (n == 0) || (n == 1) {
        return 1;
    }

    Fib(n - 1) + Fib(n - 2)
}
```

Очень важно, не забыть добавить аттрибут #[no_mangle] на требуемую функицю, т.к в противном случае комипиллятор заменит имя вашей функции на что-то вроде: `_аgs@fs34`. И экспортируюя ее в PHP, libffi просто не найдет в динамической библиотеке функции с именем Fib. Подробнее можно почитать тут  https://en.wikipedia.org/wiki/Name_mangling.
Так-же в Cargo.toml нужно добавить аттрибут:
```
[lib]
crate-type = ["cdylib"]
```
Хотел бы обратить внимание на то, что есть три варианта динамической библиотеки посредством атрибута в Cargo.toml.
1. dylib - Rust shared library с нестабильным ABI, который может измениться от версии к версии (как и в ГО internal ABI)
2. cdylib - динамическая библиотека для использования в C/C++. Это наш выбор.
3. rlib - Rust static library with rlib extestion (.rlib). Содержит так-же метаданные используемые для линковки различных rlib написанных соответственно на Rust

Компиллируем: `cargo build --release`. И в папке `target/release` видим `.so` файл. Это и будет наша динамическая библиотека.

Далее на очереди C++.
Тут тоже все довольно просто:
```cpp
// in php_cpp_ffi.cpp

int main() {
    
}

extern "C" int Fib(int n) {
    if ((n==1) || (n==2)) {
        return 1;
    }

    return Fib(n-1) + Fib(n-2);
}
```















https://github.com/golang/go/blob/860c9c0b8df6c0a2849fdd274a0a9f142cba3ea5/src/cmd/cgo/doc.go#L378-L471






Есть ограничения. Это должен быть реально Си (во входных и возврщаемых параметрах). Внутри exten метода, можно производить преобразования в C++ структуры данных.
Данный подход конечно не пропогандирует переписать все и вся, однако, можно провести эксперимент на очень горячих местах-молотилках.
